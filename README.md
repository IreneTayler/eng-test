# Тестовое задание – Технический анализ

В данном документе представлен мой анализ архитектурных и технических решений, использованных в проекте.

---

## 1. Аутентификация (JWT)

В проекте используется JWT для аутентификации, и это оправданный выбор для современного веб-приложения.

JWT хорошо подходит для SPA и распределённых систем, так как позволяет реализовать stateless-аутентификацию. Серверу не требуется хранить сессии, что упрощает масштабирование и снижает нагрузку на backend.

В своих проектах (React + Node.js) я также использовала JWT. Для повышения безопасности токены сохранялись в httpOnly cookies вместо localStorage. Такой подход удобен для:
- защиты API
- управления пользовательскими сессиями
- реализации авторизации

Однако у JWT есть и недостатки:
- сложно реализовать принудительный logout, если токен ещё действителен
- требуется логика refresh-токенов
- хранение в localStorage увеличивает риск XSS

Для небольших приложений или систем с повышенными требованиями к безопасности в некоторых случаях может быть более удобна классическая session-based аутентификация.

В целом, JWT является практичным и обоснованным решением для современных веб-приложений.

---

## 2. Использование UUID

UUID часто используется в качестве первичного идентификатора в распределённых системах. Его основное преимущество — возможность генерации уникальных значений без обращения к базе данных.

В своих проектах я работала как с автоинкрементными integer-идентификаторами, так и с UUID.

UUID полезен, когда:
- система может масштабироваться или состоять из нескольких сервисов
- необходимо скрыть реальное количество записей
- идентификаторы должны генерироваться на стороне клиента

Недостатки UUID:
- больший размер по сравнению с integer
- снижение производительности индексов в базе данных
- менее удобен для отладки и анализа логов

В небольших монолитных приложениях я чаще использую integer-ID из-за лучшей производительности и простоты. UUID более оправдан в системах, рассчитанных на масштабирование.

---

## 3. Организация кода (NestJS / React, Services, DI)

Разделение на controllers и services, а также использование dependency injection значительно улучшает поддерживаемость и масштабируемость проекта.

В своих проектах я придерживаюсь похожего подхода:
- слоистая архитектура
- вынесение бизнес-логики в сервисы
- разделение UI и API-логики
- модульная структура

Преимущества:
- упрощается тестирование
- легче расширять функциональность
- удобнее работать в команде
- уменьшается связанность компонентов

При этом избыточная архитектура может замедлять разработку в небольших проектах. В pet-проектах или MVP я стараюсь соблюдать баланс между чистой архитектурой и скоростью разработки.

В целом, выбранная структура соответствует best practices для production-приложений.

---

## 4. Реактивность в React

Реактивный подход React упрощает разработку интерфейсов. UI автоматически обновляется при изменении состояния, что исключает необходимость ручной работы с DOM.

В своих проектах я активно использую React Hooks:
- useState
- useEffect
- useMemo

Преимущества:
- предсказуемое обновление интерфейса
- удобное управление состоянием
- хорошая масштабируемость компонентов

Сложности:
- лишние перерисовки при неправильном управлении состоянием
- необходимость оптимизации (React.memo, useCallback)
- усложнение логики при большом количестве состояний

Для более сложных сценариев (глобальное состояние, сложные формы) я использовала Context API и дополнительные инструменты управления состоянием.

По сравнению с прямой работой с DOM, реактивный подход React более безопасен и эффективен для разработки современных интерфейсов.

---

## Обо мне

Full-Stack разработчик с опытом работы с:
- React
- Node.js
- REST API
- архитектурой современных веб-приложений

Я уделяю внимание чистоте и поддерживаемости кода, а также разработке масштабируемых решений. Рассматриваю возможности удалённой работы и долгосрочного сотрудничества.